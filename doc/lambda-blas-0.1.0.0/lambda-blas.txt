-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A native haskell implementation of the BLAS library
--   
--   BLAS is a is a FORTRAN 77 library developed by the NSF and DOE to
--   provide highly precise and efficient implementations of basic linear
--   algebra operations. There have been several attempts to interface
--   Haskell with BLAS (hblas, blas, blas-hs, HBlas, hmatrix to name a
--   few), but they all suffer from the same limitation - they attempt to
--   call an existing C library from Haskell. The user of those
--   implementations are faced with a Cornelian dilemma: perform
--   computations in Haskell using possibly unsafe operations on pointers
--   to C data structures, or to incur a potentially enormous cost in
--   marshaling Haskell data structures each time a BLAS call is invoked.
--   This library takes a different approach. Rather than attempt to access
--   an existing BLAS library in C, we provide native Haskell
--   implementations of the basic linear algebra subroutines. To ensure our
--   code is pure and thread safe, our functions may have slightly
--   different type signatures than their FORTRAN counterparts.
@package lambda-blas
@version 0.1.0.0

module Numerical.BLAS.Types
data GivensRot a
GIVENSROT :: {-# UNPACK #-} !(a, a, a, a) -> GivensRot a

-- | ModGivensRot is a data structure for containing the linear operator
--   obtained from the rotmg function. The values h11, h12, h21, and h22
--   are the elements of the linear operator. The four cases correspond two
--   the value of the SFLAG.
data ModGivensRot a
FLAGNEG2 :: ModGivensRot a
FLAGNEG1 :: !a -> ModGivensRot a
[d1, d2, x1, h11, h12, h21, h22] :: ModGivensRot a -> !a
FLAG0 :: !a -> ModGivensRot a
[d1, d2, x1, h12, h21] :: ModGivensRot a -> !a
FLAG1 :: !a -> ModGivensRot a
[d1, d2, x1, h11, h22] :: ModGivensRot a -> !a
instance GHC.Generics.Generic (Numerical.BLAS.Types.ModGivensRot a)
instance GHC.Show.Show a => GHC.Show.Show (Numerical.BLAS.Types.ModGivensRot a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Numerical.BLAS.Types.ModGivensRot a)
instance GHC.Generics.Generic (Numerical.BLAS.Types.GivensRot a)
instance GHC.Show.Show a => GHC.Show.Show (Numerical.BLAS.Types.GivensRot a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Numerical.BLAS.Types.GivensRot a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Numerical.BLAS.Types.GivensRot a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Numerical.BLAS.Types.ModGivensRot a)


-- | This module provides BLAS level-1 library functions for vectors of
--   single precision floating point numbers. In general, BLAS level-1
--   functions that take vector valued arguments support the ability to
--   apply their functionality over all the elements in the vector, or to a
--   smaller vector comprised of elements drawn in uniform intervals from
--   the original vector argument. This capability allows vector operations
--   to be applied, for example, to columns of matrices.
--   
--   To support this capability, each BLAS level-1 function that has at
--   least one vector valued argument takes an Int parameter, n, that
--   represents the number of elements to be extracted from the vector
--   arguments. The function also will take an additional Int argument for
--   each vector valued argument, representing the both the direction of
--   traversal and the interval between elements are drawn of the original
--   vector argument. Typically n is the first Int valued argument, and the
--   increments are the first Int valued argment following a vector
--   agument.
--   
--   For example:
--   
--   <pre>
--   sdot :: Int -&gt; Vector Float -&gt; Int -&gt; Vector Float -&gt; Int -&gt; Float
--   sdot n sx incx sy incy = foldl' (+) 0 $ zipWith (*) (sampleElems n sx incx) (sampleElems n sy incy)
--   </pre>
--   
--   is morally equivalent to the dot product of the vectors sx and sy when
--   both vectors have lengths of n and both incx and incy are unity.
--   
--   The BLAS functions do not generally guard against invalid values of
--   the increment arguments. For each vector argument v, and each
--   increment inc, the calling program should ensure that:
--   
--   <pre>
--   inc /= 0
--   length v &gt;= (1 + (n-1)*inc)
--   </pre>
module Numerical.BLAS.Single

-- | O(n) - asum computes the sum of the absolute value of elements drawn a
--   vector, x. This function is morally equivalent to the L1 norm when n
--   is equal to the length of x and incx is unity.
asum :: (Num a, Storable a) => Int -> Vector a -> Int -> a

-- | <i>Deprecated: Use asum instead</i>
sasum :: Int -> Vector Float -> Int -> Float

-- | <i>Deprecated: Use asum instead</i>
dasum :: Int -> Vector Double -> Int -> Double

-- | O(n) - nrm2 computes the sum of the squared values of elements drawn a
--   vector, x. This function is morally equivalent to the L2 norm when n
--   is equal to the length of x and incx is unity.
nrm2 :: (Floating a, Ord a, Storable a) => Int -> Vector a -> Int -> a

-- | <i>Deprecated: Use nrm2 instead</i>
snrm2 :: Int -> Vector Float -> Int -> Float

-- | <i>Deprecated: Use nrm2 instead</i>
dnrm2 :: Int -> Vector Double -> Int -> Double

-- | O(n) - compute the sum of products of elements drawn from two Float
--   vectors. This function is morally equivalent to the dot product of
--   vectors x and y when n is the length of both x and y, and both incx
--   and incy are unity.
dot :: (Storable a, Num a) => Int -> Vector a -> Int -> Vector a -> Int -> a

-- | <i>Deprecated: Use dot instead.</i>
sdot :: Int -> Vector Float -> Int -> Vector Float -> Int -> Float

-- | <i>Deprecated: Use dot instead.</i>
ddot :: Int -> Vector Double -> Int -> Vector Double -> Int -> Double

-- | O(n) - compute the sum of products of elements drawn from two Float
--   vectors using Double precision internally. This function is morally
--   equivalent to the dot product of vectors x and y when n is the length
--   of both x and y, and both incx and incy are unity.
sdsdot :: Int -> Float -> Vector Float -> Int -> Vector Float -> Int -> Float

-- | O(n) - Multiply selected elements in a vector, x, by a scalar, a. This
--   function is morally equivalent to scalar multiplication a*x when n is
--   the length x and incx is unity.
scal :: (Storable a, Num a) => Int -> a -> Vector a -> Int -> Vector a

-- | <i>Deprecated: Use scal instead.</i>
sscal :: Int -> Float -> Vector Float -> Int -> Vector Float

-- | <i>Deprecated: Use scal instead.</i>
dscal :: Int -> Double -> Vector Double -> Int -> Vector Double

-- | O(n) apply a plane rotation to elements drawn from a pair of vectors.
--   This is morally equivalent to rotating both vectors through an angle
--   when n is equal to the length of both the vectors, and both incx and
--   incy are unity.
rot :: (Storable a, Num a) => Int -> Vector a -> Int -> Vector a -> Int -> a -> a -> (Vector a, Vector a)

-- | <i>Deprecated: Use rot instead.</i>
srot :: Int -> Vector Float -> Int -> Vector Float -> Int -> Float -> Float -> (Vector Float, Vector Float)

-- | <i>Deprecated: Use rot instead.</i>
drot :: Int -> Vector Double -> Int -> Vector Double -> Int -> Double -> Double -> (Vector Double, Vector Double)

-- | O(1) Construct a plane Givens rotation on a deconstructed two-vector.
--   Specifically:
--   
--   <pre>
--   rotg sa sb = ( r, secant(theta), cos(theta), sin(theta))
--   </pre>
--   
--   where r is the signed magnitude of the vector <a>sa,sb</a>. In the
--   case when r is zero, rotg returns (0,0,1,0). See also "rot".
rotg :: (Fractional a, Floating a, Ord a) => a -> a -> GivensRot a

-- | <i>Deprecated: Use rotg instead.</i>
srotg :: Float -> Float -> GivensRot Float

-- | <i>Deprecated: Use rotg instead.</i>
drotg :: Double -> Double -> GivensRot Double

-- | O(n) apply a modified Givens rotation to elements drawn from a pair of
--   vectors according to the following specification:
--   
--   <pre>
--   srotm FLAGNEG2 n sx incx sy incy = (sx,sy)
--   srotm (FLAGNEG1 h11 h12 h21 h22) n sx incx sy incy =
--      ( updateElems ( x y -&gt; h11*x + h12*y) n sx incx sy incy
--      , updateElems ( y x -&gt; h21*x + h22*y) n sy incy sx incx)
--   srotm (FLAG0 h12 h21) n sx incx sy incy =
--      ( updateElems ( x y -&gt; x + h12*y) n sx incx sy incy
--      , updateElems ( y x -&gt; h21*x + y) n sy incy sx incx)
--   srotm (FLAG1 h11 h22) n sx incx sy incy =
--      ( updateElems ( x y -&gt; h11*x + y) n sx incx sy incy
--      , updateElems ( y x -&gt; -x + h22*y) n sy incy sx incx)
--   </pre>
--   
--   see also "rotmg".
rotm :: (Storable a, Num a) => ModGivensRot a -> Int -> Vector a -> Int -> Vector a -> Int -> (Vector a, Vector a)

-- | <i>Deprecated: Use rotm instead</i>
srotm :: ModGivensRot Float -> Int -> Vector Float -> Int -> Vector Float -> Int -> (Vector Float, Vector Float)

-- | <i>Deprecated: Use rotm instead</i>
drotm :: ModGivensRot Double -> Int -> Vector Double -> Int -> Vector Double -> Int -> (Vector Double, Vector Double)

-- | O(1) Construct a modified plane Givens rotation on a deconstructed
--   two-vector as described in "Basic Linear Algebra Subprograms for
--   Fortran Use", Lawson 1979. The solution should satisfy
--   
--   | d1 0 | | h11 h12 | | sx1/x1 | | sd1 0 | | sx1 | | 0 d2 | | h21 h22 |
--   | sy1/x1 | = G | 0 sd2 | | sx2 | @
--   
--   where G is the Givens rotation matirx. d1, d2 and x1 are rescaled by
--   the the "checkscale" subprogram to be within the conservative limits
--   of +<i>- 1</i>(4096)^2 and +/- 4096^2.
--   
--   See also "rotm".
rotmg :: (Ord a, Fractional a) => a -> a -> a -> a -> ModGivensRot a

-- | <i>Deprecated: Use rotmg instead.</i>
srotmg :: Float -> Float -> Float -> Float -> ModGivensRot Float

-- | <i>Deprecated: Use rotmg instead.</i>
drotmg :: Double -> Double -> Double -> Double -> ModGivensRot Double

-- | O(n) compute the linear combination of elements drawn from two vectors
--   according. This is morally equivalent to the linear combination of the
--   two vectors when n is the length of the vectors and both incx and incy
--   are unity.
axpy :: (Storable a, Num a) => Int -> a -> Vector a -> Int -> Vector a -> Int -> Vector a

-- | <i>Deprecated: Use axpy instead.</i>
saxpy :: Int -> Float -> Vector Float -> Int -> Vector Float -> Int -> Vector Float

-- | <i>Deprecated: Use axpy instead.</i>
daxpy :: Int -> Double -> Vector Double -> Int -> Vector Double -> Int -> Vector Double

-- | O(n) - Copy n elements from one Float vector into another.
copy :: (Storable a) => Int -> Vector a -> Int -> Vector a -> Int -> Vector a

-- | <i>Deprecated: Use copy instead</i>
scopy :: Int -> Vector Float -> Int -> Vector Float -> Int -> Vector Float

-- | <i>Deprecated: Use copy instead</i>
dcopy :: Int -> Vector Double -> Int -> Vector Double -> Int -> Vector Double

-- | O(n) -- Swap n elements between two Float vectors.
swap :: (Storable a) => Int -> Vector a -> Int -> Vector a -> Int -> (Vector a, Vector a)

-- | <i>Deprecated: Use swap instead.</i>
sswap :: Int -> Vector Float -> Int -> Vector Float -> Int -> (Vector Float, Vector Float)

-- | <i>Deprecated: Use swap instead.</i>
dswap :: Int -> Vector Double -> Int -> Vector Double -> Int -> (Vector Double, Vector Double)

-- | O(n) - Find the index of the element with the largest absolute value
--   from elements drawn from a vector. This function is morally equivalent
--   to the index of the element with the largest magnitude when n is the
--   length of the vector x and the increment, inc, is unity.
iamax :: (Ord a, Num a, Storable a) => Int -> Vector a -> Int -> Int

-- | <i>Deprecated: use iamax instead</i>
isamax :: Int -> Vector Float -> Int -> Int

-- | <i>Deprecated: use iamax instead</i>
idamax :: Int -> Vector Double -> Int -> Int


-- | This module re-exports the BLAS level 1 functions for Floating point
--   and complex data types
module Numerical.BLAS
